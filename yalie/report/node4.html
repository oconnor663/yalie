<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Builtin Objects and Methods</TITLE>
<META NAME="description" CONTENT="Builtin Objects and Methods">
<META NAME="keywords" CONTENT="report">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="report.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="report.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html49"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html47"
  HREF="report.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html41"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html50"
  HREF="node5.html">Conclusions</A>
<B> Up:</B> <A NAME="tex2html48"
  HREF="report.html">Yet Another Lisp Interpreting</A>
<B> Previous:</B> <A NAME="tex2html42"
  HREF="node3.html">Syntax</A>
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00040000000000000000">
Builtin Objects and Methods</A>
</H1>
The meat of the Yalie language is in its builtin objects and
methods. As we have seen, object literals all inherit from parent
objects that will be exposed to the user for potential
modification. These parent objects will have methods defined for their
children to inherit.

<P>
We will formally specify only a few methods here. A short description
of all the methods used by the interpreter can be found in the
accompanying README file.

<P>
In order to specify these methods, we will need a few helper
functions. The lookup function, <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.png"
 ALT="$ L$"></SPAN>, takes a store, an object
reference, and a method name and returns the method of that name
belonging to the closest ancestor of the object.
<P></P>
<DIV ALIGN="CENTER"><!-- MATH
 \begin{multline*}
L(\sigma,o,\text{``name''}) = \phi_1(\text{``name''}) \text{ if
  ``name''} \in \phi_1 \\\text{else }L(\sigma,p,\text{``name''}),
\end{multline*}
 -->
<IMG
 WIDTH="522" HEIGHT="58" ALIGN="BOTTOM" BORDER="0"
 SRC="img23.png"
 ALT="\begin{multline*}
L(\sigma,o,\text{\lq\lq name''}) = \phi_1(\text{\lq\lq name''}) \text{ ...
...\lq\lq name''} \in \phi_1 \\ \text{else }L(\sigma,p,\text{\lq\lq name''}),
\end{multline*}"></DIV>
<BR CLEAR="ALL">
<P><P></P>
where <!-- MATH
 $\sigma(o)=(p,\phi_1,\phi_2,d)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="138" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$ \sigma(o)=(p,\phi_1,\phi_2,d)$"></SPAN>.

<P>
The method invoker, <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img25.png"
 ALT="$ M$"></SPAN>, returns the value of a method call on a given
object under a given scope and store. That is, it invokes functions
which return an object reference, a new scope, and a new store.
<P></P>
<DIV ALIGN="CENTER"><!-- MATH
 \begin{multline*}
M(\phi,\sigma,o,\text{``name''},\left<a_1,\ldots a_n\right>)
 =\\f( \phi, \sigma, o, \left<a_1, \ldots a_n\right> )
\end{multline*}
 -->
<IMG
 WIDTH="521" HEIGHT="58" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.png"
 ALT="\begin{multline*}M(\phi,\sigma,o,\text{\lq\lq name''},\left&lt;a_1,\ldots a_n\right&gt;)
=\\ f( \phi, \sigma, o, \left&lt;a_1, \ldots a_n\right&gt; )
\end{multline*}"></DIV>
<BR CLEAR="ALL">
<P><P></P>
where <!-- MATH
 $f = L(\sigma,o,\text{``name''})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="80" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img27.png"
 ALT="$ f = L(\sigma,o,$">``name''<IMG
 WIDTH="10" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img28.png"
 ALT="$ )$"></SPAN>.

<P>
Lastly, our wrapper function, <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img29.png"
 ALT="$ W$"></SPAN>, takes a function of some arguments
and returns a function that implicitly evaluates those arguments
before beginning. This is necessary because the ``call'' function will
need to circumvent implicit evaluation of arguments. Evaluation is
accomplished by the ``eval'' method, which each object will define.
<P></P>
<DIV ALIGN="CENTER"><!-- MATH
 \begin{multline*}
W(f)(\phi,\sigma,o,\left<a_1,\ldots a_n\right>) =
f(\phi,\sigma,o,\left<e_1,\ldots e_n\right>)
\end{multline*}
 -->
<IMG
 WIDTH="521" HEIGHT="34" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.png"
 ALT="\begin{multline*}
W(f)(\phi,\sigma,o,\left&lt;a_1,\ldots a_n\right&gt;) =
f(\phi,\sigma,o,\left&lt;e_1,\ldots e_n\right&gt;)
\end{multline*}"></DIV>
<BR CLEAR="ALL">
<P><P></P>
where <!-- MATH
 $e_i = M(\phi,\sigma,a_i,\text{``eval''},\left<\right>)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="112" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$ e_i = M(\phi,\sigma,a_i,$">``eval''<IMG
 WIDTH="29" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.png"
 ALT="$ ,\left&lt;\right&gt;)$"></SPAN>.

<P>
Now we can define some of the important methods. The basic
<TT>eval</TT> function simply returns the value of the caller.
<P><!-- MATH
 \begin{displaymath}
\phi_{\text{ROOT}}(\text{``eval''})(\phi,\sigma,o,\left<\right>) =
(o,\phi,\sigma) 
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<IMG
 WIDTH="253" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.png"
 ALT="$\displaystyle \phi_{\text{ROOT}}(\text{\lq\lq eval''})(\phi,\sigma,o,\left&lt;\right&gt;) =
(o,\phi,\sigma) $">
</DIV><P></P>
where <!-- MATH
 $\sigma_{\text{ROOT}}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="51" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$ \sigma_{\text{ROOT}}$"></SPAN> is the method scope of the root
object. Most objects inherit this method, with the exception of
symbols and lists. The symbol ``eval'' method is
<P><!-- MATH
 \begin{displaymath}
\phi_{\text{SYMBOL}}(\text{``eval''})(\phi,\sigma,o,\left<\right>) =
(\phi(d_{\sigma(o)}),\phi,\sigma). 
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<IMG
 WIDTH="322" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$\displaystyle \phi_{\text{SYMBOL}}(\text{\lq\lq eval''})(\phi,\sigma,o,\left&lt;\right&gt;) =
(\phi(d_{\sigma(o)}),\phi,\sigma). $">
</DIV><P></P>
Finally, for lists,
<P><!-- MATH
 \begin{displaymath}
\phi_{\text{CONS}}(\text{``eval''})(\phi,\sigma,o,\left<\right>) =
M(\phi',\sigma',e_1,\text{``call''},\left<a_2,\ldots a_n\right>)
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<IMG
 WIDTH="411" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$\displaystyle \phi_{\text{CONS}}(\text{\lq\lq eval''})(\phi,\sigma,o,\left&lt;\right&gt;) =
M(\phi',\sigma',e_1,\text{\lq\lq call''},\left&lt;a_2,\ldots a_n\right&gt;) $">
</DIV><P></P>
where <!-- MATH
 $\left< a_1,\ldots a_n\right>$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="77" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.png"
 ALT="$ \left&lt; a_1,\ldots a_n\right&gt;$"></SPAN> are the contents of the list, and
<!-- MATH
 $(e_1,\phi',\sigma') = M(\phi,\sigma,a_1,\text{``eval''},\left<\right>)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="170" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$ (e_1,\phi',\sigma') = M(\phi,\sigma,a_1,$">``eval''<IMG
 WIDTH="29" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.png"
 ALT="$ ,\left&lt;\right&gt;)$"></SPAN>.

<P>
For an example of the use of the <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img29.png"
 ALT="$ W$"></SPAN> wrapper, the method for addition
over the integers is
<P><!-- MATH
 \begin{displaymath}
\phi_{\text{INT}}(\text{``eval''}) = W
\lambda(\phi,\sigma,o,\left<e_1\right>).(n,\phi,\sigma')
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<IMG
 WIDTH="291" HEIGHT="35" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.png"
 ALT="$\displaystyle \phi_{\text{INT}}(\text{\lq\lq eval''}) = W
\lambda(\phi,\sigma,o,\left&lt;e_1\right&gt;).(n,\phi,\sigma') $">
</DIV><P></P>
where
<!-- MATH
 $n = (\text{INT},\phi_0,{\phi_2}_{\text{INT}},d_{e_1}+d_{\sigma(o)})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="$ n = ($">INT<IMG
 WIDTH="162" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$ ,\phi_0,{\phi_2}_{\text{INT}},d_{e_1}+d_{\sigma(o)})$"></SPAN> and
<!-- MATH
 $\sigma' = [\sigma|\operatorname{next}(\sigma)\rightarrow n]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="152" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$ \sigma' = [\sigma\vert\operatorname{next}(\sigma)\rightarrow n]$"></SPAN>.

<P>
Finally, here is the critical ``call'' method for the <TT>msg</TT>
function object.
<P></P>
<DIV ALIGN="CENTER"><!-- MATH
 \begin{multline*}
\phi_{\text{MSG}}(\text{``call''})(\phi,\sigma,o,\left<a_1,a_2,
  \ldots a_n \right>) = \\M(\phi,\sigma,a_1,d_{a_2}, \left<a_3,\ldots
  a_n\right>).
\end{multline*}
 -->
<IMG
 WIDTH="522" HEIGHT="58" ALIGN="BOTTOM" BORDER="0"
 SRC="img43.png"
 ALT="\begin{multline*}
\phi_{\text{MSG}}(\text{\lq\lq call''})(\phi,\sigma,o,\left&lt;a_1,a_...
...) = \\ M(\phi,\sigma,a_1,d_{a_2}, \left&lt;a_3,\ldots
a_n\right&gt;).
\end{multline*}"></DIV>
<BR CLEAR="ALL">
<P><P></P>

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html49"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html47"
  HREF="report.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html41"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html50"
  HREF="node5.html">Conclusions</A>
<B> Up:</B> <A NAME="tex2html48"
  HREF="report.html">Yet Another Lisp Interpreting</A>
<B> Previous:</B> <A NAME="tex2html42"
  HREF="node3.html">Syntax</A></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
Jack O'Connor
2009-05-04
</ADDRESS>
</BODY>
</HTML>
