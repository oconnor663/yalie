Brief documentation for the Yalie language:

Syntax
------
# is comments
['] or [`] are quoters, and [,] and [;] are unquote and unquote-splice,
respectively.
[.] is the method operator. It can operate as an infix without parens,
or it can capture an S-expression if placed after the first element.
a.b  -->  (msg a b)
(a.b c d)  -->  (msg a b c d)


Functions
---------

(dir) returns a list of everything defined in the current scope. Call
it to see what is available in the language, or if you forget the name
of something.

(= a b)
(+ a b c ...)
(- a b c ...)
(* a b c ...)
(/ a b)
(% a b)
<, >, <=, >=, =
Arithmetic and comparison functions work as they do in Scheme or
Common Lisp. % function computes the remainder as in Python.

(cons x y)
(car a)
(cdr a)
(setcar a x)
(setcdr a x)
Operations on cons cells work as in Scheme.

(if bool conseq alt)
As in Scheme. (if) can also accept more argumends, in which case it
behaves like cond. For instance:
(if a b
    c d
    e f
      g)
returns b if a, c if d, e if f, or else g. Nil is returned when all
tests are false and no unpaired last element is supplied.

(while test
   body1
   body2
   ...)
(break)
(continue)
Runs a while loop as in Python. The (break) and (continue) functions
will result in errors if called outside of a while context.

(len list)
(ls 1 2 3 4)
(append '(1 2 3) '(4 5 6))
List functions work as in Scheme, except that "list" has been renamed
"ls". (Both for brevity and to free up the variable name.)

(def (f x)
  body1
  body2
  ...)
Function definitions can be specified with an arbitrary number of
arguments. If a variable number of arguments is desired, the final
argument should be specified as (rest x), where x is whatever name you
like. I.e.
(def (foo x y (rest z))
   x.print
   y.print
   z.print)

The macro definition form, (deform), works similarly. Macros don't
implicitly evaluate their arguments, and their return values are
implicitly evaluated. The anonymous counterparts to (def) and (deform)
are (fn) and (form), respectively.

`(a b c)  ==  (quote a b c)  -->  (a b c)
`(a b ,(ls 1 2))  ==  (quote a b (unquote (+ 1 1))) --> (a b (1 2))
`(a b ;(ls 1 2)) ==  (quote a b (unquote-splice (ls 1 2)))
      	     	     	    --> (a b 1 2))


(do  body1
     body2
     body3...)  Simply evaluates each and returns the last.

(call f a b c ... list) calls the function f with a list of args. If
final argument to 'call' is a list (or nil), then the list of
arguments passed to f is composed of each argument before the last
cons'ed onto the front of the last argument.
(call + '(1 2 3))   -->   6
(call + 1 2 '(3))   -->   6
(call + 1 2 3)      -->   6


(let (a x)
  body1
  ....)
Works similarly to let* in Scheme, but drops all the inner
  parentheses. Definint multiple variables looks like this
(let (a x
      b y
      c z)
  (foo a b c))
It is also possible to define a local variable that persists for the
duration of the calling scope by omitting a body from let. This can
only be done for one variable at a time, and all the parents are
dropped.
(let a 9)
## Now a evaluates to 9 out here, until the end of this scope

(set a x) modifies an existing binding. In order to clearly
distinguish functional from non-functional operators, (let a x) is not
allowed to modify an existing binding if one already exists for 'a' in
the current scope. (Though obviously, if provided a body, let will
create its own scope without any problems.) Set should do that instead.

A few other functions like (eval x) and (print x) simply defined as
the appropriate method calls.


Methods
-------

The most important methods are those of the root object, since all
other objects inherit them.

x.child and x.copy return new objects that either inherit from or
duplicate x, respectively

(x.get key) returns the value of the member named key, or raises an
error.
(x.set key val) changes the value of the member or adds a new member
if one of that name did not exist before.

(x.def ...) and (x.deform ...) work similarly to the function and
macro constructs above, except the function name is not part of the
list of arguments in the definition. All user defined methods bind the
variable "self" implicitly. For instance, this works really
well:
(Int.def ! ()
  (if (= self 0)
      1
      (* self (- self 1).! )))
### Now all integers have a factorial method, even literal ones
### i.e. this works:  7.!