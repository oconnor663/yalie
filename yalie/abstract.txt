One of the historical attractions of the Lisp family of programming
languages has been their flexibility. Lisp was one of the first
languages to include dynamic typing, and Lisp macros allow the
programmer to create new binding forms and control structures.
Another strength of Lisp is its elegance. The S-expression syntax
allows Lisp to treat lists as code. Where most languages have code and
data, Lisp has only data. In the long run, fewer "moving parts" means
fewer distinct concepts that a programmer needs to keep in mind to
understand his language.

More recent developments, however, have seen Lisp fall behind. In
particular, the Smalltalk language demonstrated that it is possible to
treat everything in a language as an "object." Though several
object-oriented variants of Lisp have been developed, including the
Common Lisp Object System, these have not achieved nearly the same
widespread use. We wish to suggest that one of the failings of various
Lisp object systems is that they are built for the wrong reasons.

Through object-orientation, Smalltalk was able to achieve both
flexibility and simplicity. These goals are essentially orthogonal to
the goal of facilitating an object-oriented programming (OOP)
style. Lisp object systems have attempted the latter, and as a result
they have generally made their languages more complicated and less
consistent. We believe that objects can greatly enhance Lisp's core
strengths, but only if these concepts are introduced consistently
throughout the entire language.

This is the goal of Yet Another Lisp Interpreting Experiment (or,
"Yalie"). We present a variant of Lisp in which everything is an
object and all function calls are based on message passing. In doing
this, we hope to make the language less complicated, rather than more
so. An interactive interpreter for Yalie, written in Python,
accompanies this paper.
