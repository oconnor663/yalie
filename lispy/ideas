There needs to be a function for generating a fresh global scope
containing all builtin functions and constants. These will be used as
base Env objects for imported namespaces.

Everything an object?
How does python handle "a = 7 ; if x: ..." for printint value?
Are python functions/classes objects themselves?


Symbols referenced from an imported module do not actually have to be
the exact same objects as the originals. The Global environment can
create a new symbol object whose lookup properties point work
differently from that symbol in its original context. Since the two
can never be eq'd, this won't cause any problems.

Eventually add support for pronouns :)

no function should ever need to make sure that it's arguments are
legally lists. This should be checked by eval or apply.

difference between interactive and noninteractive regarding postfix
operators. (no. require that postfixing of array ref [and of
method/member ref?] have no whitespace?)

"let" needs to check for globalness to do temporary replaces.  it
should also be able to temporarily overwrite car's, cdr's, and other
data fields in the same temporary way. (how would the (let a b)
operator resolve its own scope? perhaps it can refuse to do that
because of the parens required to take a car. but the same problem
exists for global variables...)

When let is called as (let x y), it should throw an exception if x is
a global variable, because the scope will not be well defined? (Unless
we want to start adding termination conditions to
callstacks. Actually, this could be helpful in implementing
unwind-protect...)

can let define a recursive function? lambda has to hang on its lexical
scope, but 
(let a (lambda (x)
       	 (if (= x 0)
	     x 
	     (a (- x 1)))))

"if" should take an arbitrary number of args, as in "cond" but w/o
parentheses. like arc.

Member/method reference: Classes superclass Environment? Environments
as objects? The member operator "." finds the member in the referenced
namespace. If the member is a function (method), it will be wrapped in
a lambda that automatically passes the instance as the first argument.
OR--
Member operator is ':' and operates on symbol lookup. Namespaces
(envs) need to be objects in userspace!!! Symbol lookup knows how to
tell the difference between a namespace (or classdef) and an instance
of a class with regard to wrapping methods in the appropriate
lambda. YESSSS!!!!! This is how to do it.

Builtin polymorphic functions should check for class methods.

There will be no Python Class/Lisp Class dichotomy, as there is for
functions and forms.

class Lispy_Class():
   def __init__( self, E, parents_list ):
   	  self.E = E  #E is kept solely for associating new methods
	  	      #with their lexical scope. No method/member
	      	      #lookups will use it.
	  self.parents_list = parents_list
   def lookup( self, symbol ):
       ### Will need to be prepared to wrap methods.

(class My_Class (Parent1 ... Parentn) (arg1...argn)
   (


TYPES:
Cons
Atom:
  Int
  Float
  Array
  Dict
  String (no char)
  Fn
  Form
  Env?
  Stack?
  Class/Instance?

SPECIAL FORMS:
eval
quote
fn (lambda)
def
def-locally (will be called by "let")
deform
call
if (subsumes cond)
tag goto ret unwind-protect (Py?) (will modify Stack objects)

PREDEFINED LISP FORMS:
for
while
do (optional block name?)
let
ref

PREDEFINED PYTHON FUNCTIONS:
cons car cdr setcar setcdr
+ - * / // % = < <= > >=
and or not
{array,dict,string}
null
isnum iscons ... ot just (type ...)
pr (print) ...
dir (as in Python!)

PREDEFINED LISP FUNCTIONS
ls (list)
len
map
append
ret
