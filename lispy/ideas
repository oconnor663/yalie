__Symbols__
Contain a cons list of lookup envs?
Can't be envs because parse is at runtime.
Cons list must contain other symbols.
(Remember that even imported Global envs share symbols with the main)
How to print? Easy, now that it contains symbols.
Now environments must contain the symbols
    to append to new symbols they generate.
NO: what if environments didn't modify their
    symbols at all? Does that cause any problems?
Symbols need a cons list of other symbols? That's not symmetric...
Symbols rather need a cons list of strings.
How does all this interact with globals...?
THERE SHOULD BE NO SPECIAL GLOBALS. ALL LEXICAL!!! 
(This would be limiting...)
Should environments have a special parent for the builtins...?
Toplevel envs (including imported ones) should.
Then they can only shadow builtins locally.
How will globals work on import?
ALL envs share the symbols list, but lexically
    related envs can share a globals list.
Symbol lookup: globals->lexical(->builtins)
WAIT!!! Can symbols hold their own bindings? That would be WAY
	faster for lookups. 
INTERESTING THOUGHT: Symbol identity can be used to distinguish between
same-named symbols that refer to different environments.
	   This would allow symbols to hold their own
	   bindings somewhat better.

----------THE IDEA-------------: There is a meta-global list of symbol
namestrings by which symbols can be compared. The symbol object stores
its bound value. These objects are created at readtime by referencing
a simple list of already-instantiated symbols. This list is the
lexical environment. A "global" directive a la Python allows symbols
to be pulled down from higher scopes. DOES THIS POSE A PROBLEM FOR
RESOLVING IMPORT SCOPES, WHICH CAN CHANGE AT RUNTIME? Take another cue
from Python: imports create genuine userspace objects, not new
symbols. Referencing an object in a module is no different from
referencing an index from a list. But that ruins the gain from having
symbols hold their own values. To have this work, imported modules
must NOT be in userspace, so that symbols within them can be resolved
at readtime. On the other hand, the main speed advantage is in
compiling individual functions, not in looking them up.

Things to do immediately:
    input (DONE!)
    quoting/unquoting (DONE!)
    function parameters (DONE!)
    exceptions (Done, but see below)
    stack unwinding (Working! but no protect yet)
    imports, classes

Idiosyncratic rules:
    symbols may not begin with a digit (this restriction has been lifted)
    pre/postfix syntax must be on the same line (this is necessary)

Syntax:
    # comments
    ` semiquote
    , unquote
    ; unquote-splice
    @ ref
    "/' strings/raw

Other symbols to make use of:
    & (binary operator for and?)
    $ 
    [ ]
    { } (used as an alternative delimiter for body expressions?)
    | (replacement for dotted lists?!?!)
    \
    ~ (special syntax for "not"?)   


Scrap the :b keyword arguments to functions. Instead allow {}
delimiters to be substituded for () whenever the expression will
contain a body. This is a sufficient signal to indenters, and it makes
missing parentheses much easier for the interpreter to identify in
error messages.

Could a continuation-passing style allow for a recursive eval function?

When everything is a pointer in C, it becomes easier to make
everything an object. Use the enum type.

All environments should point to the same dictionary for get_sym. This
should be independent of the "parent" field, so that imported modules
can still share symbols with the global scope.  OR!!!  Environments
can have their imported names stored in the class. Then, when symbols
are looked up inside that environment, the names are automatically
adjusted!!! SWEET IDEA!!!

UNWIND-PROTECT SHOULD BE A FEATURE OF fn (and form?)! "break" can be
just a goto statement inside the predefined loops

FORBID TOPLEVEL [] SYNTAX! (Brilliant!) (Terrible?) (just reset the
input after complete lines, so as to trigger a 'no [ at beginning of
file error'?) 
NO! Require that prefix and postfix syntax be on the same line as the
values they operate on. Enforce this rule both in the REPL and in text
code. Use the peek_token() function to enable this.
HERE: The REPL should only accept single forms on any given line. The parser
should parse entire files before starting evaluation.

Exceptions need to be built from the entire stack. They should be
built in place without being passed up the stack. If nothing "catches"
the exception, it can then be RETURNED directly from lisp_eval.

The parser should signal an error for malformatted keywords, for
instance symbols such as ":keyword:member". Also, consider introducing
special syntax into the parser to make it easier to catch a failure to
close parentheses.

There needs to be a function for generating a fresh global scope
containing all builtin functions and constants. These will be used as
base Env objects for imported namespaces.

Everything an object? Yes!
How does python handle "a = 7 ; if x: ..." for printint value? Answer: poorly.
Are python functions/classes objects themselves?

Symbols referenced from an imported module do not actually have to be
the exact same objects as the originals. The Global environment can
create a new symbol object whose lookup properties point work
differently from that symbol in its original context. Since the two
can never be eq'd, this won't cause any problems.  DIFFERENT APPROACH:
Environments will take a parameter giving their imported context. All
symbol lookups will thus add module names to the front end of any
symbols within them. This dovetails with the notion that all
Environments will share a list of symbols with the importing env.

Eventually add support for pronouns :)

no function should ever need to make sure that it's arguments are
legally lists. This should be checked by eval or apply.

"let" needs to check for globalness to do temporary replaces.  it
should also be able to temporarily overwrite car's, cdr's, and other
data fields in the same temporary way. (how would the (let a b)
operator resolve its own scope? perhaps it can refuse to do that
because of the parens required to take a car. but the same problem
exists for global variables...) (Perhaps I can reuse the
"unwind-protect" functionality to accomplish this...)

When let is called as (let x y), it should throw an exception if x is
a global variable, because the scope will not be well defined? (Unless
we want to start adding termination conditions to
callstacks. Actually, this could be helpful in implementing
unwind-protect...)

can let define a recursive function? lambda has to hang on its lexical
scope, but 
(let a (lambda (x)
       	 (if (= x 0)
	     x 
	     (a (- x 1)))))

"if" should take an arbitrary number of args, as in "cond" but w/o
parentheses. like arc.

Member/method reference: Classes superclass Environment? Environments
as objects? The member operator "." finds the member in the referenced
namespace. If the member is a function (method), it will be wrapped in
a lambda that automatically passes the instance as the first argument.
OR--
Member operator is ':' and operates on symbol lookup. Namespaces
(envs) need to be objects in userspace!!! Symbol lookup knows how to
tell the difference between a namespace (or classdef) and an instance
of a class with regard to wrapping methods in the appropriate
lambda. YESSSS!!!!! This is how to do it.

Builtin polymorphic functions should check for class methods.

There will be no Python Class/Lisp Class dichotomy, as there is for
functions and forms.

class Lispy_Class():
   def __init__( self, E, parents_list ):
   	  self.E = E  #E is kept solely for associating new methods
	  	      #with their lexical scope. No method/member
	      	      #lookups will use it.
	  self.parents_list = parents_list
   def lookup( self, symbol ):
       ### Will need to be prepared to wrap methods.

(class My_Class (Parent1 ... Parentn) (arg1...argn)
   (


TYPES:
Cons
Atom:
  Int
  Float
  Array
  Dict
  String (no char)
  Fn
  Form
  Env?
  Stack?
  Class/Instance?

SPECIAL FORMS:
quote
fn (lambda)
form (as lambda, but for a macro)
set-globally
set-locally (will be called by "let")
if-goto
unwind-protect (Py?) (will modify Stack objects) (part of fn?)

PREDEFINED LISP FORMS:
semiquote
if
goto
tag
return?
def,deform
for
while
do (optional block name?)
let
ref
call

PREDEFINED PYTHON FUNCTIONS:
eval
cons car cdr setcar setcdr
+ - * / // % = < <= > >=
id (test whether two pointers point to the same place)
is? (eq)
and or not
{array,dict,string}
null
isnum iscons ... ot just (type ...)
put (print) ...
dir (as in Python!)
exit

PREDEFINED LISP FUNCTIONS
ls (list)
len
map
append
ret
